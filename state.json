{"progs":[{"locals":["pitch","volume"],"name":"testo","prog":"#include \"math.h\"\n#include \"sound.h\"\n\nenum Bindings {\n    LOC_pitch,\n    LOC_volume,\n    LOC_started_at,\n    LOC_released_at,\n\n    GLOB_fm_mod,\n    GLOB_fm_freq,\n};\n\ndouble\ntone(uint64_t sample_rate, double pitch, uint64_t t) {\n    double period_real = sample_rate \/ pitch;\n    double period_f = floor(period_real);\n    double period_err = period_real - period_f;\n\n    \/\/ TODO this shifts frequencies around inconsistently\n    \/\/ because this rounds the same direction every sample\n    \/\/ (but fixing this will also require matching\n    \/\/ frequencies...)\n    uint64_t period = (uint64_t)round(sample_rate \/ pitch);\n#if 0\n    return t % period >= period \/ 2 ? 1.0 : -1.0;\n#elif 0\n    uint64_t half_period = (period + 1) \/ 2;\n    uint64_t p_t = t % period;\n    double p_t_2_frac = 2.0 * (p_t % half_period) \/\n                        (double)(half_period)-1.0;\n\n    return (p_t < half_period ? 1.0 : -1.0) * p_t_2_frac;\n#else\n    return sin(\n            2 * PI * pitch * (t) \/ (double)(sample_rate));\n#endif\n}\n\ndouble note(\n        const ValueInput* input,\n        const int* local_idxs,\n        bool* expire) {\n    double pitch = input->values[local_idxs[LOC_pitch]].d;\n    double volume = input->values[local_idxs[LOC_volume]].d;\n    uint64_t started_at =\n            input->values[local_idxs[LOC_started_at]].u;\n    uint64_t released_at =\n            input->values[local_idxs[LOC_released_at]].u;\n\n    double fm_mod =\n            input->values[local_idxs[GLOB_fm_mod]].d;\n    double fm_freq =\n            input->values[local_idxs[GLOB_fm_freq]].d;\n\n    uint64_t rel_t = input->t - started_at;\n    double r = 0;\n#if 0\n    r += 0.6 * tone(input->sample_rate, pitch, rel_t);\n    r += 0.4 * tone(input->sample_rate, 2 * pitch, rel_t);\n    r += 0.2 * tone(input->sample_rate, 3 * pitch, rel_t);\n    r += 0.1 * tone(input->sample_rate, 4 * pitch, rel_t);\n    r += 0.07 * tone(input->sample_rate, 5 * pitch, rel_t);\n    r += 0.02 * tone(input->sample_rate, 5 * pitch, rel_t);\n#else\n    double p_mod = (2 * fm_freq - 1) * 80000. \/ pitch;\n    double p_shift = (2 * fm_mod - 1) * 400000. \/ pitch;\n    double t_mod = p_mod * tone(input->sample_rate, pitch, rel_t);\n    r += 0.5 * tone(input->sample_rate, pitch, rel_t + t_mod + p_shift);\n#endif\n\n    \/\/ TODO try a fancier envelope\n\n    \/\/ TODO make params\n    const double A = 0.01;\n    const double D = 0.08;\n    const double S = 0.35;\n    const double R = 0.3;\n\n    double t = (input->t - started_at) \/\n               (double)input->sample_rate;\n    if (t <= A) {\n        r *= t \/ A;\n    } else if (t <= D + A) {\n        r *= ((S - 1) \/ D) * (t - A) + 1;\n    } else {\n        if (false) {\n            r *= S;\n        } else {\n            double p = (t - D - A + 1);\n            r *= S \/ (p * p);\n        }\n    }\n    \/\/ TODO is this condition bad?\n    if (released_at >= started_at) {\n        double expire_t = (input->t - released_at) \/\n                          (double)input->sample_rate;\n        double s = -(1 \/ R) * expire_t + 1;\n        if (s <= 0) {\n            *expire = true;\n            return 0;\n        }\n        r *= s;\n    }\n\n    r *= volume;\n\n    return r;\n}\n"},{"locals":["pitch","volume"],"name":"testo2","prog":"hgdshdghasfg"}]}