{
    "progs": [
        {
            "locals": [
                "pitch",
                "volume"
            ],
            "name": "testo",
            "prog": "#include \"math.h\"\n#include \"sound.h\"\n\nenum Bindings {\n    LOC_pitch,\n    LOC_volume,\n    LOC_started_at,\n    LOC_released_at,\n\n    GLOB_fm_mod,\n    GLOB_fm_freq,\n};\n\ndouble\ntone(uint64_t sample_rate, double pitch, uint64_t t) {\n    \/\/ TODO does this run into precision issues?\n    double t_f = (double)(t);\n    double period = sample_rate \/ pitch;\n    double half_period = period \/ 2;\n    double t_m = fmod(t_f, period);\n    \n#if 0\n    return t_m >= half_period ? 1.0 : -1.0;\n#elif 1\n    double p_t_2_frac = 2 * fmod(t_m, half_period) \/ half_period - 1;\n\n    return (t_m < half_period ? 1.0 : -1.0) * p_t_2_frac;\n#else\n    return sin(\n            2 * PI * pitch * (t) \/ (double)(sample_rate));\n#endif\n}\n\ndouble note(\n        const ValueInput* input,\n        const int* local_idxs,\n        bool* expire) {\n    double pitch = input->values[local_idxs[LOC_pitch]].d;\n    double volume = input->values[local_idxs[LOC_volume]].d;\n    uint64_t started_at =\n            input->values[local_idxs[LOC_started_at]].u;\n    uint64_t released_at =\n            input->values[local_idxs[LOC_released_at]].u;\n\n    double fm_mod =\n            input->values[local_idxs[GLOB_fm_mod]].d;\n    double fm_freq =\n            input->values[local_idxs[GLOB_fm_freq]].d;\n\n    uint64_t rel_t = input->t - started_at;\n    double r = 0;\n#if 1\n    r += 0.6 * tone(input->sample_rate, pitch, rel_t);\n    r += 0.4 * tone(input->sample_rate, 2 * pitch, rel_t);\n    r += 0.2 * tone(input->sample_rate, 3 * pitch, rel_t);\n    r += 0.1 * tone(input->sample_rate, 4 * pitch, rel_t);\n    r += 0.07 * tone(input->sample_rate, 5 * pitch, rel_t);\n    r += 0.02 * tone(input->sample_rate, 5 * pitch, rel_t);\n#else\n    double p_mod = (2 * fm_freq - 1) * 80000. \/ pitch;\n    double p_shift = (2 * fm_mod - 1) * 400000. \/ pitch;\n    double t_mod = p_mod * tone(input->sample_rate, pitch, rel_t);\n    r += 0.5 * tone(input->sample_rate, pitch, rel_t + t_mod + p_shift);\n#endif\n\n    \/\/ TODO try a fancier envelope\n\n    \/\/ TODO make params\n    const double A = 0.01;\n    const double D = 0.08;\n    const double S = 0.35;\n    const double R = 0.3;\n\n    double t = (input->t - started_at) \/\n               (double)input->sample_rate;\n    if (t <= A) {\n        r *= t \/ A;\n    } else if (t <= D + A) {\n        r *= ((S - 1) \/ D) * (t - A) + 1;\n    } else {\n        if (false) {\n            r *= S;\n        } else {\n            double p = (t - D - A + 1);\n            r *= S \/ (p * p);\n        }\n    }\n    \/\/ TODO is this condition bad?\n    if (released_at >= started_at) {\n        double expire_t = (input->t - released_at) \/\n                          (double)input->sample_rate;\n        double s = -(1 \/ R) * expire_t + 1;\n        if (s <= 0) {\n            *expire = true;\n            return 0;\n        }\n        r *= s;\n    }\n\n    r *= volume;\n\n    return r;\n}\n"
        },
        {
            "locals": [],
            "name": "testo2",
            "prog": "hgdshdghasfg"
        }
    ]
}