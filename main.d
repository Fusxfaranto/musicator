import std.algorithm : max, move, sort, swap;
import std.array : appender;
import std.conv : to;
import std.datetime : dur;
import std.exception : enforce;
import std.file : readText, write;
import std.json : JSONValue, parseJSON;
import std.math : exp2, log2, PI, pow, round, fmod, _sin = sin;
import std.process : executeShell;
import std.stdio : writeln, writefln;
import std.string : fromStringz;

import core.stdc.string : strlen;
import core.thread : Thread;

import serial;
import util;
import websocket;

import c_bindings;

import rtmidi_c;
import tcc.libtcc;

alias fast_float_type = float;
fast_float_type sin(fast_float_type f) {
    return _sin(f);
}

// extern (C) void midi_callback(double deltatime,
//         const(ubyte)* message,
//         size_t message_size, void* priv) {
//     writefln("%s\t%s", deltatime,
//             message[0 .. message_size]);
// }

enum StreamId : ulong {
    LIVE,
    TRACK,
}

enum Tuning {
    ET12,
    ET19,
    JUST,
}

struct CompiledProg {
    TCCState* tcc_state;
    ValueFn fn;
}

// TODO sequences of events should be generated by fn
struct State {
    struct Var {
        enum Type {
            I,
            D,
        }

        string name;
        Type type;
    }

    struct Prog {
        enum Type {
            MONOPHONIC,
            POLYPHONIC,
        }

        string name;
        Type type;
        Var[] locals;
        string prog;
        @NoSerial CompiledProg compiled;

        struct ProgEvent {
            enum Type {
                ON,
                OFF,
            }

            uint id;
            Type type;
            double at_time;

            // TODO these won't apply to everything, figure
            // out something cleaner?
            // incl adding separate channel field instead of
            // just using midi_note
            ubyte midi_note;
            ubyte midi_velocity;
        }
        // TODO descriptions of on/off/? events
        ProgEvent[] track_events;
    }

    string prog_helpers;
    Prog[] progs;
    int midi_prog_idx;
    uint next_prog_event_id;

    // TODO snap modes
    int snap_denominator;
    // TODO make tempo event-based, so it can be dynamic
    int tempo;
    double cursor = 0;
}

struct MidiControl {
    enum int PITCH_BEND = 128;

    ubyte channel;
    int id;
    int value;
    int max_value;
}

__gshared {
    AudioContext* ctx;
    //ulong sample_rate;
    int[][128] key_local_idxs;

    bool[128] key_held = false;
    bool[128] key_held_soft = false;
    int[12] key_pitch_offset_19;
    int last_key_held;
    bool midi_suspend = false;
    Tuning tuning = Tuning.ET12;

    MidiControl last_changed_controller;

    // TODO more precise updates
    bool ws_should_update;
    State gstate;
}

int get_key_idx(int keycode) {
    // TODO ???
    return keycode + 100;
}

void set_tuning(int key_code) {
    enum double C = 440 * exp2((72 - 69) / 12.0);

    Event e;
    e.type = EventType.EVENT_WRITE;
    e.target_idx = get_name_idx(ctx, StreamId.LIVE,
            format("test_note%s.pitch", key_code).ptr);

    int rel_note = (key_code + (128 * 12) - 72) % 12;
    int octave = (key_code - rel_note) / 12;
    double octave_scale = exp2(octave - 6.0);

    final switch (tuning) {
    case Tuning.ET12: {
            enum cents = 100;
            e.value.d = 440 * exp2((key_code - 69) * (cents / 1200.));
            add_event(ctx, StreamId.LIVE, &e);
            break;
        }

    case Tuning.ET19: {
            int alt_rel_key;
            switch (rel_note) {
            case 0:
                alt_rel_key = 0;
                break;
            case 1:
                alt_rel_key = 1;
                break;
            case 2:
                alt_rel_key = 3;
                break;
            case 3:
                alt_rel_key = 5;
                break;
            case 4:
                alt_rel_key = 6;
                break;
            case 5:
                alt_rel_key = 8;
                break;
            case 6:
                alt_rel_key = 9;
                break;
            case 7:
                alt_rel_key = 11;
                break;
            case 8:
                alt_rel_key = 13;
                break;
            case 9:
                alt_rel_key = 14;
                break;
            case 10:
                alt_rel_key = 16;
                break;
            case 11:
                alt_rel_key = 17;
                break;

            default:
                assert(0);
            }

            e.value.d = octave_scale * C * exp2(alt_rel_key / 19.);
            int p = key_pitch_offset_19[key_code % 12];
            if (p != 0) {
                assert(p == 1 || p == -1);
                e.value.d *= exp2(p / 19.);
            }
            add_event(ctx, StreamId.LIVE, &e);
            break;
        }

    case Tuning.JUST: {
            double[12] intervals;
            if (true) {
                intervals[0] = 1.0;
                intervals[1] = 16.0 / 15.0;
                intervals[2] = 9.0 / 8.0;
                intervals[3] = 6.0 / 5.0;
                intervals[4] = 5.0 / 4.0;
                intervals[5] = 4.0 / 3.0;
                intervals[6] = 25.0 / 18.0;
                intervals[7] = 3.0 / 2.0;
                intervals[8] = 8.0 / 5.0;
                intervals[9] = 5.0 / 3.0;
                intervals[10] = 9.0 / 5.0;
                intervals[11] = 15.0 / 8.0;
            }
            else {
                intervals[0] = 1.0;
                intervals[1] = 14.0 / 13.0;
                intervals[2] = 8.0 / 7.0;
                intervals[3] = 6.0 / 5.0;
                intervals[4] = 5.0 / 4.0;
                intervals[5] = 4.0 / 3.0;
                intervals[6] = 7.0 / 5.0;
                intervals[7] = 3.0 / 2.0;
                intervals[8] = 8.0 / 5.0;
                intervals[9] = 5.0 / 3.0;
                intervals[10] = 7.0 / 4.0;
                intervals[11] = 13.0 / 7.0;

            }
            e.value.d = octave_scale * C * intervals[rel_note];
            add_event(ctx, StreamId.LIVE, &e);

            break;
        }
    }
}

// TODO modes
// TODO this should differentiate between up/down
double note_snap() {
    double tempo_secs = gstate.tempo / 60.0;
    gstate.cursor += 1 / (gstate.snap_denominator * tempo_secs);
    return gstate.cursor;
}

void register_to_track(StreamId id, ref in State.Prog.ProgEvent prog_e) {
    Event e;

    ulong at_count = 0;
    if (id != StreamId.LIVE) {
        at_count = get_sample_count(ctx, prog_e.at_time);
    }
    writeln(at_count);

    // TODO define these dynamically based on prog (which will need to be input to this fn)
    final switch (prog_e.type) {
    case State.Prog.ProgEvent.Type.ON:
        e.type = EventType.EVENT_WRITE;
        e.target_idx = get_name_idx(ctx, id,
                format("test_note%s.volume", prog_e.midi_note).ptr);
        e.value.d = prog_e.midi_velocity / 128.;
        e.at_count = at_count;
        add_event(ctx, id, &e);

        e = Event.init;
        e.type = EventType.EVENT_WRITE_TIME;
        e.target_idx = get_name_idx(ctx, id,
                format("test_note%s.started_at", prog_e.midi_note).ptr);
        e.at_count = at_count;
        add_event(ctx, id, &e);

        e = Event.init;
        e.type = EventType.EVENT_SETTER;
        e.setter = ValueSetter(
                gstate.progs[gstate.midi_prog_idx].compiled.fn,
                key_local_idxs[prog_e.midi_note].ptr,
                0, get_key_idx(prog_e.midi_note));
        e.at_count = at_count;
        add_event(ctx, id, &e);
        return;

    case State.Prog.ProgEvent.Type.OFF:
        e.type = EventType.EVENT_WRITE_TIME;
        e.target_idx = get_name_idx(ctx, id,
                format("test_note%s.released_at", prog_e.midi_note).ptr);
        e.at_count = at_count;
        add_event(ctx, id, &e);
        return;
    }
}

void register_note_down(ubyte midi_note, ubyte midi_velocity) {
    // TODO should take prog id as arg
    State.Prog *prog = &gstate.progs[0];
    State.Prog.ProgEvent prog_e;

    prog_e.id = gstate.next_prog_event_id++;
    prog_e.type = State.Prog.ProgEvent.Type.ON;
    prog_e.at_time = note_snap();
    prog_e.midi_note = midi_note;
    prog_e.midi_velocity = midi_velocity;

    prog.track_events ~= prog_e;
    register_to_track(StreamId.LIVE, prog_e);

    ws_should_update = true;
}

void register_note_up(ubyte midi_note) {
    // TODO todos in register_note_down apply
    State.Prog *prog = &gstate.progs[0];
    State.Prog.ProgEvent prog_e;

    prog_e.id = gstate.next_prog_event_id++;
    prog_e.type = State.Prog.ProgEvent.Type.OFF;
    prog_e.at_time = note_snap();
    prog_e.midi_note = midi_note;
    prog_e.midi_velocity = 0;

    prog.track_events ~= prog_e;
    register_to_track(StreamId.LIVE, prog_e);

    ws_should_update = true;
}

void handle_midi_message(const ubyte[] message) {
    if (message.length > 0) {
        ubyte upper = message[0] & 0b11110000;
        ubyte channel = message[0] & 0b00001111;
        //assert(upper != 0b10000000);
        switch (upper) {
        case 0b10000000:
        case 0b10010000: {
                assert(message.length == 3);
                ubyte midi_note = message[1];
                assert(midi_note < 128);
                ubyte midi_velocity = message[2];
                assert(midi_velocity < 128);

                assert(upper != 0b10000000 || midi_velocity == 0);

                key_held[midi_note] = midi_velocity > 0;
                if (!midi_suspend || key_held[midi_note]) {
                    if (key_held[midi_note]) {
                        register_note_down(midi_note, midi_velocity);
                        last_key_held = midi_note;
                    }
                    else {
                        register_note_up(midi_note);
                    }
                    key_held_soft[midi_note] = key_held[midi_note];
                }
                break;
            }

        case 0b10110000: {
                assert(message.length == 3);
                ubyte controller = message[1];
                assert(controller < 128);
                ubyte value = message[2];
                assert(value < 128);
                double fraction = value / 127.;

                if (controller != last_changed_controller.id
                        || channel != last_changed_controller.channel) {
                    MidiControl c;
                    c.channel = channel;
                    c.id = controller;
                    c.value = value;
                    c.max_value = 127;
                    last_changed_controller = c;

                    // TODO need to be able to queue up a message to send to websocket
                }

                // TODO hack, remove
                switch (controller) {
                case 1:
                    if (false) {
                        if (tuning == Tuning.ET19) {
                            int p;
                            if (fraction < 1 / 3.) {
                                p = -1;
                            }
                            else if (fraction < 2 / 3.) {
                                p = 0;
                            }
                            else {
                                p = 1;
                            }
                            key_pitch_offset_19[last_key_held % 12] = p;
                            for (int k = last_key_held % 12; k < 128;
                                    k += 12) {
                                set_tuning(k);
                            }
                        }
                    }
                    else {
                        Event e;
                        e.type = EventType.EVENT_WRITE;
                        e.value.d = fraction;
                        e.target_idx = get_name_idx(ctx,
                                StreamId.LIVE, "fm_freq".ptr);
                        add_event(ctx, StreamId.LIVE, &e);
                    }
                    break;

                case 20:
                    if (value > 63) {
                        tuning = inc_enum(tuning);
                        for (int k = 0; k < 128; k++) {
                            set_tuning(k);
                        }
                        writefln("switching to %s", tuning);
                    }
                    break;

                case 21: {
                        Event e;
                        e.type = EventType.EVENT_WRITE;
                        e.value.d = 1;
                        for (int i = 0; i < 128; i++) {
                            e.target_idx = get_name_idx(ctx,
                                    StreamId.LIVE,
                                    format("test_note%s.pitch_offset_19",
                                        i).ptr);
                            add_event(ctx, StreamId.LIVE, &e);
                        }
                        break;
                    }

                case 24:
                    if (value > 63) {
                        writeln("scrubbing to 1");
                        Event e;
                        e.type = EventType.EVENT_RESET_STREAM;
                        e.to_count = 1;
                        add_event(ctx, StreamId.LIVE, &e);
                    }
                    break;

                case 64:
                    midi_suspend = value > 63;
                    writefln("suspend %s", midi_suspend);
                    if (!midi_suspend) {
                        Event e;
                        e.type = EventType.EVENT_WRITE_TIME;
                        for (int i = 0; i < 128; i++) {
                            if (!key_held[i] && key_held_soft[i]) {
                                e.target_idx = get_name_idx(ctx,
                                        StreamId.LIVE,
                                        format("test_note%s.released_at",
                                            i).ptr);
                                add_event(ctx, StreamId.LIVE, &e);
                                key_held_soft[i] = false;
                            }
                        }
                    }
                    break;

                default:
                    writefln("unknown controller %s, value %s",
                            controller, value);
                    break;
                }
                break;
            }

        case 0b11100000:
            ushort value = (message[2] << 7) + message[1];
            double fraction = value / cast(double)(1 << 14);

            writeln(fraction);

            Event e;
            e.type = EventType.EVENT_WRITE;
            e.value.d = fraction;
            e.target_idx = get_name_idx(ctx, StreamId.LIVE, "fm_mod"
                    .ptr);
            add_event(ctx, StreamId.LIVE, &e);
            break;

        default:
            writefln("%b: %s", upper, message);
            break;
        }
        //writefln("%b: %s", upper, message);
    }
    else {
        Thread.sleep(dur!"msecs"(10));
    }
}

// TODO could optimize
void requeue_track_events() {
    clear_events(ctx, StreamId.TRACK);

    State.Prog.ProgEvent[] prog_es;

    foreach (ref prog; gstate.progs) {
        prog_es ~= prog.track_events;
    }

    prog_es.sort!("a.at_time < b.at_time");

    foreach (ref pe; prog_es) {
        register_to_track(StreamId.TRACK, pe);
    }

    stream_scrub(ctx, StreamId.TRACK, gstate.cursor);
}

void rebuild_state() {
    foreach (ref prog; gstate.progs) {
        compile_prog(prog);
    }
}

void load_state(string filename) {
    gstate = State.init;

    JSONValue j = parseJSON(readText(filename));
    deserialize(j, gstate);

    rebuild_state();
}

struct WSMessage {
    string type;
    JSONValue contents;

    struct SaveLoad {
        string filename;
    }
}

void send_state(ref WebSocket ws) {
    WSMessage message;
    message.type = "set";
    message.contents = serialize(gstate);
    ws.send(serialize(message).toString());
}

void process_ws(ref WebSocket ws) {
    if (ws_should_update && ws.is_connected()) {
        send_state(ws);
        ws_should_update = false;
    }

    const(char[]) ws_recv = ws.recv();
    if (!ws_recv) {
        return;
    }

    writefln("recv %s", ws_recv.length);
    //writeln(ws_recv);

    WSMessage message;
    deserialize(parseJSON(ws_recv), message);

    //writeln(message);

    if (message.type == "getstate") {
        send_state(ws);
    }
    else if (message.type == "setstate") {
        deserialize(message.contents, gstate);

        // TODO only recompile what's updated
        rebuild_state();
    }
    else if (message.type == "save") {
        WSMessage.SaveLoad params;
        deserialize(message.contents, params);
        write(params.filename, serialize(gstate).toPrettyString());
    }
    else if (message.type == "load") {
        WSMessage.SaveLoad params;
        deserialize(message.contents, params);
        load_state(params.filename);

        send_state(ws);
    }
    else if (message.type == "play") {
        // TODO stream id
        requeue_track_events();
        stream_play(ctx, StreamId.TRACK);
    }
    else if (message.type == "pause") {
        // TODO stream id
        stream_pause(ctx, StreamId.TRACK);
    }
    else {
        assert(0);
    }
}

extern (C) void tcc_error_func(void* opaque, const char* msg) {
    writeln(fromStringz(msg));
    //assert(0);
}

// TODO do we really need a separate TCCState each time?
void compile_prog(ref State.Prog prog) {
    auto s = appender!string();

    s ~= `
#include "math.h"
#include "sound.h"

enum Bindings {
`;
    foreach (ref l; prog.locals) {
        s ~= "LOC_" ~ l.name ~ ",\n";
    }

    // TODO add globals from state
    s ~= `
GLOB_fm_mod,
GLOB_fm_freq,
`;
    s ~= "};\n";

    s ~= gstate.prog_helpers;
    s ~= `
double note(
        const ValueInput* input,
        const int* local_idxs,
        bool* expire) {
`;

    foreach (ref l; prog.locals) {
        string type;
        string accessor;
        final switch (l.type) {
        case State.Var.Type.I:
            type = "uint64_t";
            accessor = "u";
            break;
        case State.Var.Type.D:
            type = "double";
            accessor = "d";
            break;
        }
        s ~= format_s(
                "%s %s = input->values[local_idxs[LOC_%s]].%s;\n",
                type, l.name, l.name, accessor);
    }

    // TODO add globals from state
    s ~= `
    double fm_mod =
            input->values[local_idxs[GLOB_fm_mod]].d;
    double fm_freq =
            input->values[local_idxs[GLOB_fm_freq]].d;
`;

    s ~= prog.prog ~ "\n}\0";
    //writeln(prog.locals);
    //writeln(s);

    void compile_internal(ref TCCState* tcc_state_src) {
        TCCState* tcc_state = tcc_new();
        enforce(tcc_state);

        tcc_set_error_func(tcc_state, null, &tcc_error_func);
        enforce(tcc_set_output_type(tcc_state, TCC_OUTPUT_MEMORY) == 0);
        tcc_set_lib_path(tcc_state, "tcc");
        enforce(tcc_add_library(tcc_state, "m") == 0);
        enforce(tcc_add_sysinclude_path(tcc_state, "tcc/include") == 0);

        {
            auto r = tcc_compile_string(tcc_state, s[].ptr);
            if (r != 0) {
                tcc_delete(tcc_state);
                return;
            }
        }

        static if (true) {
            tcc_relocate(tcc_state, TCC_RELOCATE_AUTO);
        }
        else {
            auto n = tcc_relocate(tcc_state, null);
            prog.mem = new void[n];
            tcc_relocate(tcc_state, prog.mem.ptr);
        }

        if (tcc_state_src) {
            tcc_delete(tcc_state_src);
        }
        tcc_state_src = tcc_state;
    }

    compile_internal(prog.compiled.tcc_state);
    if (prog.compiled.tcc_state) {
        prog.compiled.fn = cast(ValueFn)tcc_get_symbol(
                prog.compiled.tcc_state, "note");
        enforce(prog.compiled.fn);
    }

}

void main() {
    int[128] white_keys_map;
    {
        int c = 0;
        for (int i = 0; i < 128; i++) {
            int rel_note = (i + (128 * 12) - 72) % 12;
            if (rel_note != 1 && rel_note != 3
                    && rel_note != 6 && rel_note != 8 && rel_note != 10) {
                white_keys_map[i] = c++;
            }
            else {
                white_keys_map[i] = -1;
            }
        }
    }

    enforce(start_audio(&ctx) == 0);
    scope (exit)
        enforce(stop_audio(ctx) == 0);

    stream_play(ctx, StreamId.LIVE);

    // TODO
    load_state("state.json");

    static if (false) {
        note_fn = &test_note;

        for (int i = 0; i < key_local_idxs.length; i++) {
            key_local_idxs[i] = get_local_idx(0, TestNoteLocalIdxs.min) + i;
        }
    }
    else {
        enum string[] local_names = [
                "pitch", "volume", "started_at", "released_at",
            ];
        enum string[] global_names = ["fm_mod", "fm_freq",];
        assert(key_local_idxs.length == 128);
        for (int i = 0; i < 128; i++) {
            key_local_idxs[i] = new int[local_names.length + global_names
                .length];
            static foreach (j, name; local_names) {
                key_local_idxs[i][j] = get_name_idx(ctx,
                        StreamId.LIVE,
                        format("test_note%s.%s", i, name).ptr);
            }

            auto offset = local_names.length;
            static foreach (j, name; global_names) {
                key_local_idxs[i][j + offset] = get_name_idx(ctx,
                        StreamId.LIVE, format("%s", name).ptr);
            }
        }
    }

    {
        Event e;
        e.type = EventType.EVENT_WRITE;

        for (int key_code = 0; key_code < 128; key_code++) {
            e.target_idx = get_name_idx(ctx, StreamId.LIVE,
                    format("test_note%s.pitch_offset_19", key_code).ptr);
            e.value.d = 1;
            add_event(ctx, StreamId.LIVE, &e);

            e.target_idx = get_name_idx(ctx, StreamId.LIVE,
                    format("test_note%s.released_at", key_code).ptr);
            e.value.u = 0;
            add_event(ctx, StreamId.LIVE, &e);

            set_tuning(key_code);
        }
    }

    {
        Event e;
        e.type = EventType.EVENT_WRITE;
        e.value.d = 0.5;
        e.target_idx = get_name_idx(ctx, StreamId.LIVE, "fm_mod".ptr);
        add_event(ctx, StreamId.LIVE, &e);

        e.value.d = 0.5;
        e.target_idx = get_name_idx(ctx, StreamId.LIVE, "fm_freq".ptr);
        add_event(ctx, StreamId.LIVE, &e);
    }

    WebSocket ws = WebSocket(3001);

    enum midi_queue_size = 4096;
    RtMidiInPtr midi_p = rtmidi_in_create(
            RtMidiApi.RTMIDI_API_UNSPECIFIED, "asdf\0", midi_queue_size);
    scope (exit)
        rtmidi_in_free(midi_p);

    //rtmidi_in_set_callback(midi_p, &midi_callback, null);

    rtmidi_open_port(midi_p, 0, "asdfdsa\0");

    // TODO
    executeShell("aconnect 24:0 128:0");
    executeShell("aconnect 28:0 128:0");
    executeShell("aconnect 32:0 128:0");

    ubyte[1024] message_buf = cast(ubyte)(-1);
    for (;;) {
        size_t message_size = message_buf.length;
        double t = rtmidi_in_get_message(midi_p,
                message_buf.ptr, &message_size);

        assert(midi_p.ok, midi_p.msg[0 .. strlen(midi_p.msg)]);

        handle_midi_message(message_buf[0 .. message_size]);

        // TODO put this in a separate thread?
        process_ws(ws);
    }
}
